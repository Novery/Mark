# redis
+ 存在内存中（数据持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,），速度快（传统数据库，硬盘）
+ redis只是缓存，虽然做了持久化 但是还是背后要有db的支撑，开了aof也做不到一个数据都不丢失
### 高性能、高并发
+ 高性能
  + 数据存在缓存上，操作缓存就是直接操作内存，如果数据中数据改变了，同步改变缓存中的数据
+ 高并发
  + 缓存上承受的请求大于直接访问数据库
### 和map/guava的区别
  + java自带的map或guava实现的是本地缓存，生命周期随jvm销毁而结束，在多实例的情况下，每个实例都需要各自保存缓存，缓存不具有一致性
  + redis，分布式缓存，多实例共用，缺点是需要保持redis高可用，架构上较为复杂
###  redis设置过期时间
  + 对过期数据批量删除，比如token或者登陆信息
  + 定时删除，随机抽取，过期则删除（随机而不是遍历，性能考虑）
  + 惰性删除，定时删除漏掉的，只有查询到这个key，才会删除
### redis事务
  + 通过multi、exec、watch等命令实现事务，事务提供了一种机制，将多个请求打包，一次性按顺序执行所有命令，期间不会处理其他客户端请求命令
### 缓存穿透和缓存雪崩
  + 雪崩，缓存同一时间大面积失效，后面请求都落到数据库，造成数据库短时间承受大量请求而崩溃
  + 解决方案：
    + 事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
    + 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
    + 事后：利用 redis 持久化机制保存的数据尽快恢复缓存
  + 缓存穿透,黑客故意去请求缓存中不存在的数据，导致所有请求落到数据库，造成数据库短期承受大量请求而崩塌
  + 解决方案，采用布隆过滤器，将所有可能存在的数据hash到一个足够大的bitmap上，一个一定不存在的数据会被这个bitmap拦截掉
### 淘汰策略（6种）
  + volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
  + volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
  + volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
  + allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
### 分布式锁
  + 并发竞争key，多个系统同时对key操作，执行顺序与我们期望不同
  + redis，zookeeper都可以实现分布式锁，会影响性能
### 保证缓存数据库一致性
  + 读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况
  + 串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

# Redis的使用
### 环境准备
+ [redis官网](https://redis.io)
+ 官网提供的是linux版，github有提供window版
+ [安装Ubuntu，提供windows的Linux子系统](https://baijiahao.baidu.com/s?id=1608773578329225793&wfr=spider&for=pc)

### 使用
+ 安装
```
apt-get update

apt-get install redis-server
```
+ 查看是否启动
```
ps -aux|grep redis
```
+ 查看版本
```
redis-server -v

```
+ 通过命令行客户端访问redis
```
redis-cli
```
+ 修改配置文件
```
vi 文件名
sudo nano /etc/redis/redis.conf
sudo命令以系统管理者的身份执行指
```
+ 重启重启Redis服务器。
```
sudo /etc/init.d/redis-server restart
```
+ 增加一条字符串记录
```
set key1 "hello"
```
+ 查看字符串记录
```
get key1
```
