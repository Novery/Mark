# redis
+ 存在内存中（数据持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,），速度快（传统数据库，硬盘）
+ redis只是缓存，虽然做了持久化 但是还是背后要有db的支撑，开了aof也做不到一个数据都不丢失
### 高性能、高并发
+ 高性能
  + 数据存在缓存上，操作缓存就是直接操作内存，如果数据中数据改变了，同步改变缓存中的数据
+ 高并发
  + 缓存上承受的请求大于直接访问数据库
### 和map/guava的区别
  + java自带的map或guava实现的是本地缓存，生命周期随jvm销毁而结束，在多实例的情况下，每个实例都需要各自保存缓存，缓存不具有一致性
  + redis，分布式缓存，多实例共用，缺点是需要保持redis高可用，架构上较为复杂
###  redis设置过期时间
  + 对过期数据批量删除，比如token或者登陆信息
  + 定时删除，随机抽取，过期则删除（随机而不是遍历，性能考虑）
  + 惰性删除，定时删除漏掉的，只有查询到这个key，才会删除
### redis事务
  + 通过multi、exec、watch等命令实现事务，事务提供了一种机制，将多个请求打包，一次性按顺序执行所有命令，期间不会处理其他客户端请求命令
### 缓存穿透和缓存雪崩
  + 雪崩，缓存同一时间大面积失效，后面请求都落到数据库，造成数据库短时间承受大量请求而崩溃
  + 解决方案：
    + 事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
    + 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
    + 事后：利用 redis 持久化机制保存的数据尽快恢复缓存
  + 缓存穿透,黑客故意去请求缓存中不存在的数据，导致所有请求落到数据库，造成数据库短期承受大量请求而崩塌
  + 解决方案，采用布隆过滤器，将所有可能存在的数据hash到一个足够大的bitmap上，一个一定不存在的数据会被这个bitmap拦截掉
### 淘汰策略（6种）
  + volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
  + volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
  + volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
  + allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
### 分布式锁
  + 并发竞争key，多个系统同时对key操作，执行顺序与我们期望不同
  + redis，zookeeper都可以实现分布式锁，会影响性能
### 保证缓存数据库一致性
  + 读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况
  + 串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。


# Zookeeper
+ 分布式协调服务
+ 自带可重入锁
+ 注册中心
### 设计
+ 允许分布式进程通过共享的层次结构命名空间进行相互协调，（树形结构）与标准文件系统类似。
+ 但数据保存在内存上，可以实现高吞吐量和低延迟
+ ***顺序访问***
  + 来自客户端的每一次请求，会分配一个全局递增编号，也叫时间戳，反应了事务操作的先后顺序
+ ***高性能***
  + 读多写少场景地位高，写会导致所有zk服务器同步状态
### 概念
+ ZooKeeper是一个典型的分布式数据一致性解决方案
+ ZooKeeper是高性能的。在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）
+ ZooKeeper本身就是个分布式程序，半数节点存活，就能正常工作
+ 为了保证高可用，最好以集群的方式部署
### 分布式锁
+ 基于zookeeper临时有序节点可以实现分布式锁，大致思想：每个客户端对某个方法加锁时，在zookpeer上与该方法对应的节点目录下，生成一个唯一的瞬时有序节点，判断是否获取锁的方式很简单，有序节点中顺序最小的一个，当释放锁，删除瞬时节点，同时，可以避免服务宕机导致的锁无法释放，产生的死锁问题，完成业务流程后，删除对应的节点释放锁
+ zookeeper分布式锁，思路，先在locker节点下创建临时有序节点，再getchildren拿到locker下所有节点，判断序列号是否最小，如果最小则拿到锁，释放锁需删除节点，如果不是则对当前最小节点进行监听，释放后再次走判断逻辑直到拿到锁
### 会话
+ session指Zookeeper服务器与客户端会话，客户端通过tcp长连接，并采用心跳检测与服务器保持有效会话
+ 会话的相关机制都基于sessionId,客户端的sessionid全局唯一
### 节点
+ zk将数据存储在内存上，数据结构是一棵树，每个数据单元是一个节点
+ 分为持久节点和临时节点（临时节点生命周期和客户端会话绑定）
### Watcher（事件监听器）
+ zk允许在指定节点注册一些watcher
+ 当特定事件触发后，通知感兴趣的客户端，该机制是实现了分布式协调服务的重要特性（比如zk分布式锁）
### zk特点
+ 顺序一致性：从同一客户端发起的事务请求，最终按这个次序应用到zk中
+ 原子性：整个集群中所有机器要么都应用某个事务，要么都没应用
+ 单一系统映像：无论连接到哪个zk服务器，看到的数据模型都一致
+ 可靠性：持久化

### ZAB协议与Paxos算法
+ Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算
### ZAB
+ 原子广播协议，支持崩溃恢复和消息广播，实现分布式数据一致性
+ 经典集群模式:主备模式，master负责写，其他通过异步复制方式获取master最新数据提供读服务
+ zk没有主备模式，取而代之是引入三种角色
  + ***leader(领导者)***：事务请求调度唯一处理者，集群内部服务调度者
  + ***跟随者***：处理非事务请求，转发事务请求给leader，参与事务请求Proposal的投票
  + ***观察者***:与跟随者唯一区别不参与选举，也不参与过半写成功策略，提升集群的读能力
+ 当leader服务器出现网络中断或者宕机重启等情况，ZAB协议进入恢复模式并选举产生新leader
  + 选举阶段：一个节点超过半数投票，就能成为准leader
  + 发现阶段：跟随着跟准leader进行通信，同步跟随着最近接收的事务提议
  + 同步阶段：根据前一阶段获取的最新提议历史，同步集群所有副本
  + 广播阶段：可以对外提供事务服务
+ ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理。Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器
### Paxos
+ proposer将发起提案（value）给所有accpetor，超过半数accpetor获得批准后，proposer将提案写入accpetor内，最终所有accpetor获得一致性的确定性取值，且后续不允许再修改。